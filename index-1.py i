import os
import sqlite3
from datetime import datetime, timedelta

from fastapi import FastAPI, Request
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    ConversationHandler,
    filters,
)

# ===================== CONFIG =====================
SHOP_NAME = "ùêíùêûùêúùêÆùê´ùêû ùêíùêÆùê´ùêü ùêôùê®ùêßùêû"
BKASH_NUMBER = "01642012385"
NAGAD_NUMBER = "01788098356"

TOKEN = os.environ["BOT_TOKEN"]
PUBLIC_URL = os.environ["PUBLIC_URL"].rstrip("/")
ADMIN_CHAT_ID = int(os.environ["ADMIN_CHAT_ID"])

DB_PATH = "shop.db"

# Checkout states
NAME, PHONE, PAYMENT, TRX = range(4)

# FastAPI app + Telegram Application (webhook)
api = FastAPI()
tg_app = Application.builder().token(TOKEN).build()


# ===================== DB HELPERS =====================
def db():
    return sqlite3.connect(DB_PATH)


def init_db():
    con = db()
    cur = con.cursor()

    # Products
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS products(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            price INTEGER NOT NULL,
            stock INTEGER NOT NULL DEFAULT 0,
            duration_days INTEGER NOT NULL DEFAULT 30,
            desc TEXT DEFAULT ''
        )
        """
    )

    # Orders
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS orders(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            name TEXT NOT NULL,
            phone TEXT NOT NULL,
            product_name TEXT NOT NULL,
            duration_days INTEGER NOT NULL,
            total INTEGER NOT NULL,
            payment_method TEXT NOT NULL,
            trx_id TEXT NOT NULL,
            expiry_date TEXT NOT NULL,
            status TEXT NOT NULL DEFAULT 'Pending',
            created_at TEXT NOT NULL
        )
        """
    )

    # Live chat state
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS user_state(
            user_id INTEGER PRIMARY KEY,
            live_chat INTEGER NOT NULL DEFAULT 0
        )
        """
    )

    con.commit()

    # Seed default products ONLY if empty
    cur.execute("SELECT COUNT(*) FROM products")
    if cur.fetchone()[0] == 0:
        seed = [
            ("Adobe Explore (1 Month) ‚Äî Available", 500, 300, 30, "Adobe Explore premium access. Delivery after verification."),
            ("Adobe Explore (3 Month) ‚Äî Available", 1350, 200, 90, "Adobe Explore premium access. Delivery after verification."),
            ("Premium VPN (1 Month)", 250, 999, 30, "High-speed VPN account/config. Delivery after verification."),
            ("ChatGPT Account (1 Month)", 450, 200, 30, "ChatGPT account delivery after verification."),
            ("Gemini Pro (1 Month)", 400, 200, 30, "Gemini Pro access delivery after verification."),
        ]
        cur.executemany(
            "INSERT INTO products(name,price,stock,duration_days,desc) VALUES (?,?,?,?,?)",
            seed,
        )
        con.commit()

    con.close()


def set_live_chat(user_id: int, enabled: bool):
    con = db()
    cur = con.cursor()
    cur.execute(
        """
        INSERT INTO user_state(user_id, live_chat)
        VALUES (?,?)
        ON CONFLICT(user_id) DO UPDATE SET live_chat=excluded.live_chat
        """,
        (user_id, 1 if enabled else 0),
    )
    con.commit()
    con.close()


def is_live_chat(user_id: int) -> bool:
    con = db()
    cur = con.cursor()
    cur.execute("SELECT live_chat FROM user_state WHERE user_id=?", (user_id,))
    row = cur.fetchone()
    con.close()
    return bool(row and row[0] == 1)


# ===================== UI HELPERS =====================
def money(n: int) -> str:
    return f"{n}‡ß≥"


def kb_main():
    return InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("üõç Shop", callback_data="shop")],
            [InlineKeyboardButton("üí¨ Live Chat", callback_data="livechat")],
            [InlineKeyboardButton("‚ÑπÔ∏è Help", callback_data="help")],
        ]
    )


def kb_back():
    return InlineKeyboardMarkup([[InlineKeyboardButton("‚¨Ö Back", callback_data="back")]])


def kb_shop():
    con = db()
    cur = con.cursor()
    cur.execute("SELECT id, name, price FROM products WHERE stock > 0 ORDER BY id DESC")
    rows = cur.fetchall()
    con.close()

    buttons = []
    for pid, name, price in rows:
        buttons.append([InlineKeyboardButton(f"{name} ‚Äî {money(price)}", callback_data=f"p:{pid}")])
    buttons.append([InlineKeyboardButton("‚¨Ö Back", callback_data="back")])
    return InlineKeyboardMarkup(buttons)


# ===================== BOT: USER =====================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    set_live_chat(update.effective_user.id, False)
    await update.message.reply_text(
        f"üëã Welcome to {SHOP_NAME}\nDigital Services Store",
        reply_markup=kb_main(),
    )


async def endchat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    set_live_chat(update.effective_user.id, False)
    await update.message.reply_text("‚úÖ Live Chat ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§", reply_markup=kb_main())


async def on_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data
    uid = q.from_user.id

    if data == "back":
        await q.edit_message_text(f"üè† {SHOP_NAME} Menu", reply_markup=kb_main())
        return

    if data == "help":
        msg = (
            f"‚ÑπÔ∏è Help ‚Äî {SHOP_NAME}\n\n"
            "‚Ä¢ Shop ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡ßç‡¶ü ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®\n"
            "‚Ä¢ Buy Now ‚Üí ‡¶®‡¶æ‡¶Æ/‡¶´‡ßã‡¶® ‚Üí payment ‚Üí TRX ‡¶¶‡¶ø‡¶®\n"
            "‚Ä¢ Verification ‡¶∂‡ßá‡¶∑‡ßá delivery message ‡¶™‡¶æ‡¶¨‡ßá‡¶® ‚úÖ\n\n"
            f"bKash: {BKASH_NUMBER}\n"
            f"Nagad: {NAGAD_NUMBER}\n\n"
            "Support ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡¶≤‡ßá üí¨ Live Chat ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®"
        )
        await q.edit_message_text(msg, reply_markup=kb_main())
        return

    if data == "shop":
        await q.edit_message_text("üõç Available Products:", reply_markup=kb_shop())
        return

    if data == "livechat":
        set_live_chat(uid, True)
        await q.edit_message_text(
            "üí¨ Live Chat ON ‚úÖ\n"
            "‡¶è‡¶ñ‡¶® ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ/‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‚Äî‡¶è‡¶°‡¶Æ‡¶ø‡¶®‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§\n\n"
            "‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶§‡ßá /endchat ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‡•§",
            reply_markup=kb_back(),
        )
        return

    if data.startswith("p:"):
        pid = int(data.split(":")[1])
        con = db()
        cur = con.cursor()
        cur.execute("SELECT name, price, stock, duration_days, desc FROM products WHERE id=?", (pid,))
        row = cur.fetchone()
        con.close()

        if not row:
            await q.edit_message_text("‚ùå Product not found.", reply_markup=kb_shop())
            return

        name, price, stock, duration, desc = row
        expiry_preview = (datetime.now() + timedelta(days=duration)).strftime("%Y-%m-%d")

        context.user_data["selected_product"] = {
            "name": name,
            "price": price,
            "duration": duration,
        }

        text = (
            f"üì¶ {name}\n\n"
            f"üí∞ Price: {money(price)}\n"
            f"‚è≥ Validity: {duration} days\n"
            f"üìÖ Expiry After Purchase: {expiry_preview}\n"
            f"üì¶ Stock: {stock}\n\n"
            f"üìù {desc}"
        )

        kb = InlineKeyboardMarkup(
            [
                [InlineKeyboardButton("üí≥ Buy Now", callback_data="buy")],
                [InlineKeyboardButton("‚¨Ö Back to Shop", callback_data="shop")],
            ]
        )
        await q.edit_message_text(text, reply_markup=kb)
        return

    if data == "buy":
        set_live_chat(uid, False)
        await q.edit_message_text("‚úÖ Checkout ‡¶∂‡ßÅ‡¶∞‡ßÅ\n‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶®‡¶æ‡¶Æ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®:")
        return NAME


# ===================== CHECKOUT FLOW =====================
async def checkout_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["cust_name"] = update.message.text.strip()
    await update.message.reply_text("üìû ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶´‡ßã‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®:")
    return PHONE


async def checkout_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["cust_phone"] = update.message.text.strip()

    kb = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("bKash", callback_data="pay:bkash"), InlineKeyboardButton("Nagad", callback_data="pay:nagad")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="pay:cancel")],
        ]
    )
    await update.message.reply_text(
        f"üí≥ Payment method ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®:\n\nbKash: {BKASH_NUMBER}\nNagad: {NAGAD_NUMBER}",
        reply_markup=kb,
    )
    return PAYMENT


async def checkout_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    choice = q.data.split(":")[1]
    if choice == "cancel":
        await q.edit_message_text("‚ùå Checkout cancelled.", reply_markup=kb_main())
        return ConversationHandler.END

    method = "bKash" if choice == "bkash" else "Nagad"
    number = BKASH_NUMBER if choice == "bkash" else NAGAD_NUMBER
    context.user_data["payment_method"] = method

    await q.edit_message_text(
        f"‚úÖ {method} selected.\nSend money to: {number}\n\n‡¶è‡¶ñ‡¶® ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Transaction ID (TRX) ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®:"
    )
    return TRX


async def checkout_trx(update: Update, context: ContextTypes.DEFAULT_TYPE):
    trx = update.message.text.strip()
    if len(trx) < 4:
        await update.message.reply_text("TRX ID ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶¶‡¶ø‡¶®:")
        return TRX

    uid = update.effective_user.id
    product = context.user_data.get("selected_product")
    if not product:
        await update.message.reply_text("‚ùå Product select ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡¶®‡¶ø‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ /start ‡¶¶‡¶ø‡¶®‡•§", reply_markup=kb_main())
        return ConversationHandler.END

    name = context.user_data["cust_name"]
    phone = context.user_data["cust_phone"]
    payment = context.user_data["payment_method"]

    pname = product["name"]
    price = int(product["price"])
    duration = int(product["duration"])
    expiry = (datetime.now() + timedelta(days=duration)).strftime("%Y-%m-%d")
    created_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    con = db()
    cur = con.cursor()
    cur.execute(
        """
        INSERT INTO orders(user_id,name,phone,product_name,duration_days,total,payment_method,trx_id,expiry_date,status,created_at)
        VALUES (?,?,?,?,?,?,?,?,?,?,?)
        """,
        (uid, name, phone, pname, duration, price, payment, trx, expiry, "Pending", created_at),
    )
    oid = cur.lastrowid
    con.commit()
    con.close()

    # User confirmation
    await update.message.reply_text(
        f"‚úÖ Order Confirmed ‚Äî #{oid}\n\n"
        f"üì¶ Product: {pname}\n"
        f"üí∞ Price: {money(price)}\n"
        f"‚è≥ Validity: {duration} days\n"
        f"üìÖ Expiry Date: {expiry}\n\n"
        f"Payment: {payment} (TRX: {trx})\n"
        f"Status: Pending (verification ‡¶ö‡¶≤‡¶¨‡ßá)",
        reply_markup=kb_main(),
    )

    # Notify admin
    admin_msg = (
        f"üîî NEW ORDER #{oid}\n"
        f"User ID: {uid}\n"
        f"Name: {name}\nPhone: {phone}\n\n"
        f"Product: {pname}\nPrice: {money(price)}\nValidity: {duration} days\nExpiry: {expiry}\n\n"
        f"Payment: {payment}\nTRX: {trx}\n\n"
        f"Deliver with:\n/deliver {oid} <delivery_message>\n"
        f"Reply user via live chat:\n/reply {uid} <message>"
    )
    try:
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=admin_msg)
    except Exception:
        pass

    return ConversationHandler.END


# ===================== LIVE CHAT FORWARD =====================
async def forward_live_chat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    if uid == ADMIN_CHAT_ID:
        return
    if not is_live_chat(uid):
        return

    user = update.effective_user
    username = f"@{user.username}" if user.username else "(no username)"
    text = update.message.text.strip()

    admin_text = (
        "üí¨ LIVE CHAT MESSAGE\n"
        f"From: {user.full_name} {username}\n"
        f"User ID: {uid}\n"
        f"Message: {text}\n\n"
        f"Reply with:\n/reply {uid} <your_message>\n"
        f"Stop their chat:\n/stopchat {uid}"
    )
    await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=admin_text)
    await update.message.reply_text("‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")


# ===================== ADMIN COMMANDS =====================
def admin_only(update: Update) -> bool:
    return update.effective_chat and update.effective_chat.id == ADMIN_CHAT_ID


async def cmd_reply(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    if len(context.args) < 2:
        await update.message.reply_text("Usage: /reply <user_id> <message>")
        return
    user_id = int(context.args[0])
    msg = " ".join(context.args[1:]).strip()
    try:
        await context.bot.send_message(chat_id=user_id, text=f"üí¨ Support:\n{msg}")
        await update.message.reply_text("‚úÖ Replied to user.")
    except Exception:
        await update.message.reply_text("‚ùå Failed to send message (user blocked bot or invalid id).")


async def cmd_stopchat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    if len(context.args) != 1:
        await update.message.reply_text("Usage: /stopchat <user_id>")
        return
    user_id = int(context.args[0])
    set_live_chat(user_id, False)
    try:
        await context.bot.send_message(chat_id=user_id, text="‚úÖ Support chat closed. ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡¶≤‡ßá Live Chat ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®‡•§")
    except Exception:
        pass
    await update.message.reply_text("‚úÖ User live chat stopped.")


async def cmd_deliver(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    if len(context.args) < 2:
        await update.message.reply_text("Usage: /deliver <order_id> <delivery_message>")
        return

    order_id = int(context.args[0])
    delivery_message = " ".join(context.args[1:]).strip()

    con = db()
    cur = con.cursor()
    cur.execute("SELECT user_id FROM orders WHERE id=?", (order_id,))
    row = cur.fetchone()
    if not row:
        con.close()
        await update.message.reply_text("‚ùå Order not found.")
        return

    user_id = row[0]
    cur.execute("UPDATE orders SET status=? WHERE id=?", ("Delivered", order_id))
    con.commit()
    con.close()

    try:
        await context.bot.send_message(
            chat_id=user_id,
            text=f"‚úÖ Your order #{order_id} delivered!\n\n{delivery_message}\n\nThanks for shopping with {SHOP_NAME} ‚ù§Ô∏è",
        )
    except Exception:
        pass

    await update.message.reply_text(f"‚úÖ Delivered order #{order_id} + user notified.")


# ---- Product Management ----
async def cmd_addp(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    text = update.message.text.replace("/addp", "", 1).strip()
    parts = [p.strip() for p in text.split("|")]
    if len(parts) < 5:
        await update.message.reply_text("Format:\n/addp name | price | stock | duration_days | description")
        return

    name, price, stock, duration, desc = parts[0], int(parts[1]), int(parts[2]), int(parts[3]), parts[4]
    con = db()
    cur = con.cursor()
    cur.execute(
        "INSERT INTO products(name,price,stock,duration_days,desc) VALUES (?,?,?,?,?)",
        (name, price, stock, duration, desc),
    )
    con.commit()
    pid = cur.lastrowid
    con.close()
    await update.message.reply_text(f"‚úÖ Added product #{pid}")


async def cmd_products(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    con = db()
    cur = con.cursor()
    cur.execute("SELECT id,name,price,stock,duration_days FROM products ORDER BY id DESC LIMIT 200")
    rows = cur.fetchall()
    con.close()

    if not rows:
        await update.message.reply_text("No products.")
        return

    lines = ["üì¶ Products:"]
    for pid, name, price, stock, dur in rows:
        lines.append(f"#{pid} | {name} | {money(price)} | stock:{stock} | {dur} days")
    await update.message.reply_text("\n".join(lines))


async def cmd_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    if len(context.args) != 2:
        await update.message.reply_text("Usage: /price <product_id> <new_price>")
        return
    pid, new_price = int(context.args[0]), int(context.args[1])
    con = db()
    cur = con.cursor()
    cur.execute("UPDATE products SET price=? WHERE id=?", (new_price, pid))
    con.commit()
    con.close()
    await update.message.reply_text(f"‚úÖ Price updated: #{pid} => {money(new_price)}")


async def cmd_stock(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    if len(context.args) != 2:
        await update.message.reply_text("Usage: /stock <product_id> <new_stock>")
        return
    pid, new_stock = int(context.args[0]), int(context.args[1])
    con = db()
    cur = con.cursor()
    cur.execute("UPDATE products SET stock=? WHERE id=?", (new_stock, pid))
    con.commit()
    con.close()
    await update.message.reply_text(f"‚úÖ Stock updated: #{pid} => {new_stock}")


async def cmd_duration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    if len(context.args) != 2:
        await update.message.reply_text("Usage: /duration <product_id> <days>")
        return
    pid, days = int(context.args[0]), int(context.args[1])
    con = db()
    cur = con.cursor()
    cur.execute("UPDATE products SET duration_days=? WHERE id=?", (days, pid))
    con.commit()
    con.close()
    await update.message.reply_text(f"‚úÖ Duration updated: #{pid} => {days} days")


async def cmd_delp(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not admin_only(update):
        return
    if len(context.args) != 1:
        await update.message.reply_text("Usage: /delp <product_id>")
        return
    pid = int(context.args[0])
    con = db()
    cur = con.cursor()
    cur.execute("DELETE FROM products WHERE id=?", (pid,))
    con.commit()
    con.close()
    await update.message.reply_text(f"üóë Deleted product #{pid}")


# ===================== WEBHOOK =====================
@api.on_event("startup")
async def on_startup():
    init_db()
    await tg_app.initialize()
    await tg_app.bot.set_webhook(url=f"{PUBLIC_URL}/webhook")
    await tg_app.start()


@api.on_event("shutdown")
async def on_shutdown():
    await tg_app.stop()
    await tg_app.shutdown()


@api.get("/")
def home():
    return {"status": "ok", "shop": SHOP_NAME}


@api.post("/webhook")
async def webhook(req: Request):
    data = await req.json()
    update = Update.de_json(data, tg_app.bot)
    await tg_app.process_update(update)
    return {"ok": True}


# ===================== HANDLERS =====================
tg_app.add_handler(CommandHandler("start", start))
tg_app.add_handler(CommandHandler("endchat", endchat))

tg_app.add_handler(CommandHandler("deliver", cmd_deliver))
tg_app.add_handler(CommandHandler("reply", cmd_reply))
tg_app.add_handler(CommandHandler("stopchat", cmd_stopchat))

tg_app.add_handler(CommandHandler("addp", cmd_addp))
tg_app.add_handler(CommandHandler("products", cmd_products))
tg_app.add_handler(CommandHandler("price", cmd_price))
tg_app.add_handler(CommandHandler("stock", cmd_stock))
tg_app.add_handler(CommandHandler("duration", cmd_duration))
tg_app.add_handler(CommandHandler("delp", cmd_delp))

tg_app.add_handler(CallbackQueryHandler(on_button))

# Forward user text messages in live chat mode
tg_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, forward_live_chat), group=1)

# Checkout conversation
checkout_conv = ConversationHandler(
    entry_points=[CallbackQueryHandler(on_button, pattern="^buy$")],
    states={
        NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, checkout_name)],
        PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, checkout_phone)],
        PAYMENT: [CallbackQueryHandler(checkout_payment, pattern="^pay:")],
        TRX: [MessageHandler(filters.TEXT & ~filters.COMMAND, checkout_trx)],
    },
    fallbacks=[],
    allow_reentry=True,
)
tg_app.add_handler(checkout_conv)
